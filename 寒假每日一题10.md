# 寒假每日一题

## 第十天

### 1208. 翻硬币

#### 题目

小明正在玩一个“翻硬币”的游戏。

桌上放着排成一排的若干硬币。我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。

比如，可能情形是：`**oo***oooo`

如果同时翻转左边的两个硬币，则变为：`oooo***oooo`

现在小明的问题是：如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？

我们约定：把翻动相邻的两个硬币叫做一步操作。

####  输入格式

两行等长的字符串，分别表示初始状态和要达到的目标状态。

#### 输出格式

一个整数，表示最小操作步数 

#### 数据范围

输入字符串的长度均不超过100。
数据保证答案一定有解。

#### 输入样例1

```
**********
o****o****
```

#### 输出样式1

```
5
```

#### 输入样例2

```
*o**o***o***
*o***o**o***
```

#### 输出样式2

```
1
```

#### AC代码

```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

string n,m;

void turn(int x)
{
    if(n[x]=='o') n[x]='*';
    else n[x]='o';
}

int main()
{
    cin >> n >> m;
    int res=0;
    for(int i=0;i<n.size()-1;i++)
    {
        if(n[i]!=m[i]) res++,turn(i),turn(i+1);
    }
    cout << res << endl;
    return 0;
}
```

#### 解题思路

> **递推思想**

>  若第一个字符不同，则只能通过翻转第一对来调整；若相同则第一对不能修改；
>
>  若第二个字符不同，在之前字符已经修改后的基础下只能修改第二对来调整；若相同，则第二队不能修改；
>
>  同理可得，对于字符串的前n-1个字符在之前情况已经选择后只能修改一次或零次；
>
>  综上所述；只要按照顺序依次比较并记录是否调整次数即可；
>
>  $eg$ 题目给出确保答案一定有解；