# 寒假每日一题

## 第八天

### 422. 校门外的树

#### 题目

某校大门外长度为L的马路上有一排树，每两棵相邻的树之间的间隔都是1米。

我们可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0，1，2，……，L，都种有一棵树。

由于马路上有一些区域要用来建地铁。

这些区域用它们在数轴上的起始点和终止点表示。

已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。

现在要把这些区域中的树（包括区域端点处的两棵树）移走。

你的任务是计算将这些树都移走后，马路上还有多少棵树。

####  输入格式

输入文件的第一行有两个整数L和M，L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。

接下来的M行每行包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。  

#### 输出格式

输出文件包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。 

#### 数据范围

$1≤L≤10000$,
$1≤M≤100$

#### 输入样例

```
500 3
150 300
100 200
470 471
```

#### 输出样式

```
298
```

#### AC代码

```c++
#include <iostream>
#include <algorithm>

using namespace std;

typedef pair<int,int> PII;
int n,m;
PII f[110];

int main()
{
    cin >> n >> m;
    for(int i=0;i<m;i++) cin >> f[i].first >> f[i].second;
    sort(f,f+m);
    int res=0;
    int st=f[0].first,ed=f[0].second;
    for(int i=1;i<m;i++)
    {
        if(f[i].first<=ed) ed=max(ed,f[i].second);
        else{
            res+=ed-st+1;
            ed=f[i].second,st=f[i].first;
        }
    }
    res+=ed-st+1;
    cout << n+1-res;
    return 0;
}
```

#### 解题思路

> **区间合并**

> 利用pair结构存储各个区间的起点与终点，建立pair数组；
>
> 将pair数组按照各区间的起点进行排序，则合并区间会遇到两种情况：
>
> 情况一：当前区间的终点比下个区间的起点大，即两个区间存在交集；则将当前区间终点替换为当前区间的终点与下个区间终点的较大者；
>
> 情况二：当前区间的终点比下个区间的起点小，即两个区间没有交集；则保存当前区间状态，再转移到下个区间开始；
>
> $eg$ : 最后一个区间没有进行处理操作，在之前区间全部操作后，在额外处理最后一个区间； 
>