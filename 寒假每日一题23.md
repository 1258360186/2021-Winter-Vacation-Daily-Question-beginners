# 寒假每日一题

## 第二十三天

### 126. 最大的和

#### 题目

给定一个包含整数的二维矩阵，子矩形是位于整个阵列内的任何大小为1 * 1或更大的连续子阵列。

矩形的总和是该矩形中所有元素的总和。

在这个问题中，具有最大和的子矩形被称为最大子矩形。

例如，下列数组：

```
0 -2 -7 0 
9 2 -6 2 
-4 1 -4 1 
-1 8 0 -2 
```

其最大子矩形为：

```
9 2 
-4 1 
-1 8 
```

它拥有最大和15。

#### 输入格式

输入中将包含一个N*N的整数数组。

第一行只输入一个整数N，表示方形二维数组的大小。

从第二行开始，输入由空格和换行符隔开的 $N^2$ 个整数，它们即为二维数组中的 $N^2$ 个元素，输入顺序从二维数组的第一行开始向下逐行输入，同一行数据从左向右逐个输入。

数组中的数字会保持在[-127,127]的范围内。

#### 输出格式

输出一个整数，代表最大子矩形的总和。

#### 数据范围

$1≤N≤100$

#### 输入样例

```
4
0 -2 -7 0 9 2 -6 2
-4 1 -4  1 -1

8  0 -2
```

#### 输出样例

```
 15
```

#### AC代码

```c++
#include <iostream>
#include <algorithm>

using namespace std;

int n;
int g[110][110];

int main()
{
    cin >> n;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
        {
            cin >> g[i][j];
            g[i][j] += g[i-1][j];
        }
    int res = -300;
    for(int i=1;i<=n;i++)
        for(int j=i;j<=n;j++)
        {
            int last=0;
            for(int k=1;k<=n;k++)
            {
                last = max(last,0)+g[j][k]-g[i-1][k];
                res = max(res,last);
            }
        }
    cout << res ;
    return 0;
}
```

#### 解题思路

> **二维前缀和​**

>读入数据时，按照列进行前缀和的相加；
>
>枚举上下边界，把边界内的同一列的元素看作一个整体，每个整体的值就是其全部元素的累加；
>
>从左到右的枚举纵向边界，利用$g[j][k]-g[i-1][k]$来寻找每列的总和，并设置$last$存储之前的最大值；
>
>最后依次比较所得出的值得到最大值并输出；

